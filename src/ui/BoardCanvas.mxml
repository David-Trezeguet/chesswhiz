<?xml version="1.0" encoding="utf-8"?>
<mx:Canvas xmlns:mx="http://www.adobe.com/2006/mxml"
	initialize="init()">
	
<mx:Script>
	<![CDATA[
		import mx.controls.Label;

		private const offset:int = 50;

		private var _cellSize:int;
		private var _redPieces:Array = new Array(16);
		private var _blackPieces:Array = new Array(16);

		private var _pieceMap:Array = null;

		private var _table:Table = null;
		private var _topColor:String = "Black"; // Normal view: Black at the top.

		private var _lastPieceInFocus:Piece = null;
		private var _pieceSkin:int = 1;
		private var _bgColor:uint;
		private var _lineColor:uint;

		private function init() : void
		{
			_cellSize = (width - 2 * offset)/8;

			// --- Create piece objects.

			var index:int = 0;
			var color:String = "Red";
			_redPieces[0]  = new Piece(index++, "chariot",  color, 9, 0, this);
			_redPieces[1]  = new Piece(index++, "horse",    color, 9, 1, this);
			_redPieces[2]  = new Piece(index++, "elephant", color, 9, 2, this);
			_redPieces[3]  = new Piece(index++, "advisor",  color, 9, 3, this);
			_redPieces[4]  = new Piece(index++, "king",     color, 9, 4, this);
			_redPieces[5]  = new Piece(index++, "advisor",  color, 9, 5, this);
			_redPieces[6]  = new Piece(index++, "elephant", color, 9, 6, this);
			_redPieces[7]  = new Piece(index++, "horse",    color, 9, 7, this);
			_redPieces[8]  = new Piece(index++, "chariot",  color, 9, 8, this);
			_redPieces[9]  = new Piece(index++, "cannon",   color, 7, 1, this);
			_redPieces[10] = new Piece(index++, "cannon",   color, 7, 7, this);

  			for (var pawn:int = 0; pawn < 5; pawn++) {
	        	_redPieces[11 + pawn] = new Piece(index++, "pawn", color, 6, 2*pawn, this);
			}
			
			index = 0;
			color = "Black";
			_blackPieces[0]  = new Piece(index++, "chariot",  color, 0, 0, this);
			_blackPieces[1]  = new Piece(index++, "horse",    color, 0, 1, this);
			_blackPieces[2]  = new Piece(index++, "elephant", color, 0, 2, this);
			_blackPieces[3]  = new Piece(index++, "advisor",  color, 0, 3, this);
			_blackPieces[4]  = new Piece(index++, "king",     color, 0, 4, this);
			_blackPieces[5]  = new Piece(index++, "advisor",  color, 0, 5, this);
			_blackPieces[6]  = new Piece(index++, "elephant", color, 0, 6, this);
			_blackPieces[7]  = new Piece(index++, "horse",    color, 0, 7, this);
			_blackPieces[8]  = new Piece(index++, "chariot",  color, 0, 8, this);
			_blackPieces[9]  = new Piece(index++, "cannon",   color, 2, 1, this);
			_blackPieces[10] = new Piece(index++, "cannon",   color, 2, 7, this);
	
  			for (pawn = 0; pawn < 5; pawn++) {
	        	_blackPieces[11 + pawn] = new Piece(index++, "pawn", color, 3, 2*pawn, this);
			}

 			// --- Initialize the internal state.
			_resetInternalState();
		}

		public function setTable(table:Table) : void { _table = table; }
		public function getTable() : Table { return _table; }

		public function setPreferences(bgColor:uint, lineColor:uint, pieceSkin:int) : void
		{
			_bgColor   = bgColor;
			_lineColor = lineColor;
			_pieceSkin = pieceSkin;
		}

		public function reverseView() : void
		{
			_topColor = (_topColor == "Red" ? "Black" : "Red");

			// Clear the old board.
			this.graphics.clear();
			this.removeAllChildren();

			drawBoard(_bgColor, _lineColor);

			var piece:Piece = null;
			for (var i:int = 0; i < 16; i++)
			{
				piece = _redPieces[i];
				if ( ! piece.isCaptured() ) {
					piece.draw(offset, _cellSize, _pieceSkin);
				}
				piece = _blackPieces[i];
				if ( ! piece.isCaptured() ) {
					piece.draw(offset, _cellSize, _pieceSkin);
				}
			}

			if (_lastPieceInFocus) {
				_lastPieceInFocus.setFocus();
			}
		}

		public function reset() : void
		{
			// Clear the old board.
			this.graphics.clear();
			this.removeAllChildren();

			drawBoard(_bgColor, _lineColor);

			var piece:Piece = null;
			for (var i:int = 0; i < 16; i++)
			{
				piece = _redPieces[i];
				piece.setCapture(false);
				piece.setPosition( piece.getInitialPosition() );
				piece.draw(offset, _cellSize, _pieceSkin);

				piece = _blackPieces[i];
				piece.setCapture(false);
				piece.setPosition( piece.getInitialPosition() );
				piece.draw(offset, _cellSize, _pieceSkin);
			}

			if (_lastPieceInFocus)
			{
				_lastPieceInFocus.clearFocus();
				_lastPieceInFocus = null;
			}

			_resetInternalState();
		}

		public function drawBoard(bgColor:uint, lineColor:uint) : void
		{
			_bgColor        = bgColor;
			_lineColor      = lineColor;

			this.graphics.lineStyle(2, _lineColor);
			this.graphics.beginFill(_bgColor);
			this.graphics.drawRect(0, 0, this.width, this.height);
			this.graphics.endFill();

			this.graphics.lineStyle(1, _lineColor);

			for (var i:int = 0; i < 10; i++) // Horizontal lines
			{
				_drawLine(offset, offset+i*_cellSize, 8*_cellSize, 0);
			}
	
			for (i = 0; i < 9; i++) // Vertical lines
			{
				if (i == 0 || i == 8) {
					_drawLine(offset + i*_cellSize, offset, 0, _cellSize*9);
				} else {
					_drawLine(offset + i*_cellSize, offset, 0, _cellSize*4);
					_drawLine(offset + i*_cellSize, offset + 5*_cellSize, 0, _cellSize*4);
				}
			}

			// Diagonal lines to form the Fort (or the Palace).
			_drawLine(offset + 3*_cellSize, offset, 2*_cellSize, 2*_cellSize);
			_drawLine(offset + 5*_cellSize, offset, -2*_cellSize, _cellSize*2);
			_drawLine(offset + 3*_cellSize, offset + 7*_cellSize, 2*_cellSize, 2*_cellSize);
			_drawLine(offset + 5*_cellSize, offset + 7*_cellSize, -2*_cellSize, 2*_cellSize);

			const offsetLeft:int = offset;
	        const offsetTop:int = offset;
			const bDescending:Boolean = (_topColor == "Red");
			_drawHeaderRow(offsetLeft, offsetTop, bDescending);
			_drawHeaderRow(offset + _cellSize*9 + 15, offset, bDescending);
			_drawHeaderColumn(offsetLeft, offsetTop, bDescending);
			_drawHeaderColumn(offsetLeft, offsetTop + 10*_cellSize + 20, bDescending);
		}

		private function _displayPieces() : void
		{
			for (var i:int = 0; i < 16; i++)
			{
				_redPieces[i].draw(offset, _cellSize, _cellSize, _pieceSkin);
				_blackPieces[i].draw(offset, _cellSize, _cellSize, _pieceSkin);
			}
		}

		private function _drawLine(startX:int, startY:int, dX:int, dY:int):void
		{
			this.graphics.moveTo(startX, startY);
			this.graphics.lineTo(startX+dX, startY+dY);
		}

		private function _drawHeaderRow(offsetLeft:int, offsetTop:int, bDescending:Boolean) : void
		{
			const ROWS:int  = 10;
			var   top:int   = 0;
			const left:int  = offsetLeft - 40;
			var   start:int = (bDescending ? 0 : ROWS - 1);

			for (var i:int = 0; i < ROWS; i++)
			{
				top = offsetTop + (i * _cellSize) - 6; 
				_addTextField("" + start, left, top, _lineColor, 12);
				if (bDescending) { start++; }
				else             { start--; }
			}
		}

		private function _drawHeaderColumn(offsetLeft:int, offsetTop:int, bDescending:Boolean) : void
		{
			const COLS:int  = 9;
			const top:int   = offsetTop - 45;
			var   left:int  = 0;
			var   start:int = (bDescending ? COLS - 1 : 0);

			for (var i:int = 0; i < COLS; i++)
			{
				left = offsetLeft + (i * _cellSize) - 6;
				_addTextField(String.fromCharCode(97 + start), left, top, _lineColor, 12);
				if (bDescending) { start--; }
				else             { start++; }
			}
		}

		private function _addTextField(text:String, x:Number, y:Number,
									   color:uint, fontSize:uint, font:String = "Verdana") : void
		{
			var label:Label = new Label();
			label.x = x;
			label.y = y;
			label.text = text;
			label.setStyle("color", color);
			label.setStyle("fontFamily", font);
			label.setStyle("fontSize", fontSize);

			this.addChild(label);
		}

		public function getNearestCell(x:int, y:int, radius:int):Position
		{
			trace("x: " + x + " y: " + y + ", mouse x: " + this.mouseX + " y: " + this.mouseY);
			var pos:Position = new Position(-1, -1);

			var yRow:int;
			for (var i:int = 0; i < 10; i++)
			{
				yRow = offset + _cellSize * i;
				if (Math.abs(this.mouseY - yRow) < radius)
				{
					pos.row = i;
					break;
				}
			}
			
			var xColumn:int;
			for (i = 0; i < 9; i++)
			{
				xColumn = offset + _cellSize * i;
				if (Math.abs(this.mouseX - xColumn) < radius)
				{
					pos.column = i;				
					break;
				}
			}

			return pos;
		}

		public function getX(col:int) : int { return offset + col * _cellSize; }
		public function getY(row:int) : int { return offset + row * _cellSize; }

		public function getPieceByPos(pos:Position):Piece
		{
			return _pieceMap[pos.row][pos.column];
		}

		public function getPieceByIndex(color:String, index:String) : Piece {
			return (color == "Red" ? _redPieces[index] : _blackPieces[index]);
		}

		public function updatePieceMapState(piece:Piece, oldPos:Position, newPos:Position) : void
		{
			_pieceMap[newPos.row][newPos.column] = piece;
			_pieceMap[oldPos.row][oldPos.column] = null;
		}

		private function _updatePieceMap(newPos:Position, piece:Piece) : void
		{
			var capturedPiece:Piece = _pieceMap[newPos.row][newPos.column];
			var oldPos:Position = piece.getPosition();
			_pieceMap[newPos.row][newPos.column] = piece;
			_pieceMap[oldPos.row][oldPos.column] = null;
			if (capturedPiece) {
				capturedPiece.setCapture(true);
				capturedPiece.removeImage();
			}
			piece.setPosition(newPos);
		}

		public function setFocusOnPiece(piece:Piece) : void
		{
			if (_lastPieceInFocus) {
				_lastPieceInFocus.clearFocus();
				_lastPieceInFocus = null;
			}
			if (piece) {
				piece.setFocus();
				_lastPieceInFocus = piece;
			}
		}

		public function movePieceByPos(piece:Piece, newPos:Position) : void
		{
			_updatePieceMap(newPos, piece);
			piece.moveImage();

			if (_lastPieceInFocus) {
				_lastPieceInFocus.clearFocus();
			}
			piece.setFocus();
			_lastPieceInFocus = piece;
		}

		public function rewindPieceByPos(piece:Piece, curPos:Position, prevPos:Position, capturedPiece:Piece) : void
		{
			_pieceMap[prevPos.row][prevPos.column] = piece;
			_pieceMap[curPos.row][curPos.column] = capturedPiece;
			if (_lastPieceInFocus) {
				_lastPieceInFocus.clearFocus();
			}
			piece.setPosition(prevPos);
			piece.moveImage();
			if (capturedPiece) {
				capturedPiece.setCapture(false);
				capturedPiece.setPosition(curPos);
				capturedPiece.draw(offset, _cellSize, _pieceSkin);
				capturedPiece.setFocus();
				_lastPieceInFocus = capturedPiece;
			}
			else {
				piece.setFocus();
				_lastPieceInFocus = piece;
			}
		}

		public function getViewPosition(pos:Position) : Position
		{
			return ( _topColor == "Black" // normal view?
					? new Position( pos.row, pos.column )
					: new Position( Math.abs(pos.row - 9), Math.abs(pos.column - 8) ) );
		}

		public function displayStatus(status:String) : void
		{
			// TODO: Need to properly center the text.
			_addTextField(status, this.getX(3), this.getY(4) + 10, 0x33CCFF, 18);
		}

		public function displayEmptyStatus() : void
		{
			// TODO: Need to properly center the text.
			_addTextField("Empty Table", this.getX(3), this.getY(4) + 10, 0x33CCFF, 24);
		}

		public function enablePieceEvents(color:String) : void
		{
			var pieces:Array = (color == "Red" ? _redPieces : _blackPieces);
			for each (var piece:Piece in pieces) {
				piece.enableEvents();
			}
		}

		public function disablePieceEvents(color:String) : void
		{
			var pieces:Array = (color == "Red" ? _redPieces : _blackPieces);
			for each (var piece:Piece in pieces) {
				piece.disableEvents();
			}	
		}

		public function reDraw(changeSet:Array, focusPiece:Piece) : void
		{
			if (changeSet.length == 0) {
				return;
			}
			var piece:Piece;
			var captured:Boolean;
			var pos1:Position;
			var pos2:Position;
			var color:String;
			var index:int;

			for (var i:int = 0; i < changeSet.length; i++) {
				color = changeSet[i][0];
				index = parseInt(changeSet[i][1]);
				piece = (color == "Red" ? _redPieces[index] : _blackPieces[index]);
				captured = changeSet[i][4];
				pos1 = piece.getPosition();
				pos2 = new Position(changeSet[i][2], changeSet[i][3]);
				if (!captured) {
					if (piece.isCaptured()) {
						piece.setPosition(pos2);
						piece.draw(offset, _cellSize, _pieceSkin);
					}
					else {
						if (pos1.row != pos2.row || pos1.column != pos2.column) {
							piece.removeImage();
							piece.setPosition(pos2);
							piece.draw(offset, _cellSize, _pieceSkin);
						}
					}
					piece.setCapture(false);
				} else {
					if (!piece.isCaptured()) {
						piece.removeImage();
					}
					piece.setPosition(pos2);
					piece.setCapture(true);
				}
			}

			if (_lastPieceInFocus) {
				_lastPieceInFocus.clearFocus();
				_lastPieceInFocus = null;
			}
			if (focusPiece != null) {
				focusPiece.setFocus();
				_lastPieceInFocus = focusPiece;
			}
		}
		
		public function changePiecesSkin(skinIndex:int) : void
		{
			_pieceSkin = skinIndex;

			var piece:Piece = null;
			for (var i:int = 0; i < 16; i++)
			{
				piece = _redPieces[i];
				if ( ! piece.isCaptured() ) {
					piece.changeSkinIndex(_pieceSkin);
				}
				piece = _blackPieces[i];
				if ( ! piece.isCaptured() ) {
					piece.changeSkinIndex(_pieceSkin);
				}
			}

			if (_lastPieceInFocus) {
				_lastPieceInFocus.setFocus();
			}
		}

		/* =================================================================
		 *
		 *   API migrated from the 'Game' class.
		 *
		 * ================================================================= */

		private function _resetInternalState() : void
		{
			// --- Initialize piece map.
            _pieceMap = new Array(10);
			for (var k:int = 0; k < 10; k++)
			{
				_pieceMap[k] = new Array(9);
				for (var m:int = 0; m < 9; m++)
				{
					_pieceMap[k][m] = null;
				}
			}

			_pieceMap[0][0] = _blackPieces[0];
			_pieceMap[0][1] = _blackPieces[1];
			_pieceMap[0][2] = _blackPieces[2];
			_pieceMap[0][3] = _blackPieces[3];
			_pieceMap[0][4] = _blackPieces[4];
			_pieceMap[0][5] = _blackPieces[5];
			_pieceMap[0][6] = _blackPieces[6];
			_pieceMap[0][7] = _blackPieces[7];
			_pieceMap[0][8] = _blackPieces[8];
			_pieceMap[2][1] = _blackPieces[9];
			_pieceMap[2][7] = _blackPieces[10];
			for (var pawn:int = 0; pawn < 5; pawn++) {
	        	_pieceMap[3][2*pawn] = _blackPieces[11 + pawn];
			}

			_pieceMap[9][0] = _redPieces[0];
			_pieceMap[9][1] = _redPieces[1];
			_pieceMap[9][2] = _redPieces[2];
			_pieceMap[9][3] = _redPieces[3];
			_pieceMap[9][4] = _redPieces[4];
			_pieceMap[9][5] = _redPieces[5];
			_pieceMap[9][6] = _redPieces[6];
			_pieceMap[9][7] = _redPieces[7];
			_pieceMap[9][8] = _redPieces[8];
			_pieceMap[7][1] = _redPieces[9];
			_pieceMap[7][7] = _redPieces[10];
			for (pawn = 0; pawn < 5; pawn++) {
	        	_pieceMap[6][2*pawn] = _redPieces[11 + pawn];
			}
		}

	]]>
</mx:Script>
	
</mx:Canvas>
